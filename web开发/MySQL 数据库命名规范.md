## 基础规范
表存储引擎必须使用 InnoDB
表字符集默认使用 utf8，必要时候使用 utf8mb4

说明：
1）通用，无乱码风险，汉字3字节，英文1字节
2）`utf8mb4` 是 `utf8` 的超集，有存储 4 字节例如表情符号时，使用它
禁止使用存储过程，视图，触发器，Event

说明：
1）对数据库性能影响较大，互联网业务，能让站点层和服务层干的事情，不要交到数据库层
2）调试，排错，迁移都比较困难，扩展性、移植性较差
禁止在数据库中存储大文件，例如照片，可以将大文件存储在对象存储系统，数据库中存储路径
禁止在线上环境做数据库压力测试
测试，开发，线上数据库环境必须隔离
​

命名规范
库名与应用名称尽量一致。
表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只
出现数字。

说明：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。
正例：`aliyun_admin`，`rdc_config`，`level3_name`
反例：`AliyunAdmin`，`rdcConfig`，`level_3_name`
库名，表名，列名必须见名知义，长度不要超过 32 字符
说明：tmp，wushan 谁知道这些库是干嘛的
禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。
库备份必须以 bak 为前缀，以日期为后缀
从库必须以 -s 为后缀
备库必须以 -ss 为后缀
​

表设计规范
单实例表个数必须控制在 2000 个以内
单表分表个数必须控制在 1024 个以内
表必须有主键，推荐使用 UNSIGNED 整数为主键
潜在坑：删除无主键的表，如果是 row 模式的主从架构，从库会挂住
禁止使用外键，如果要保证完整性，应由应用程式实现
说明：外键使得表之间相互耦合，影响 update/delete 等 SQL 性能，有可能造成死锁，高并发情况下容易成为数据库瓶颈
建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据
单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。

说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。
表名不使用复数名词。
说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应类名也是单数形式，符合表达习惯。
表的命名最好是加上“业务名称_表的作用”。
正例：alipay_task / force_project / trade_config
表必备三字段：id, gmt_create, gmt_modified。
说明：其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 date_time 类型，前者现在时表示主动创建，后者过去分词表示被动更新。
​

列设计规范
小数类型为 decimal，禁止使用 float 和 double。
说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。
如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。
根据业务区分使用 tinyint/int/bigint，分别会占用 1/4/8 字节
根据业务区分使用 char/varchar

说明：
1）字段长度固定，或者长度近似的业务场景，适合使用 `char`，能够减少碎片，查询性能高
2）字段长度相差较大，或者更新较少的业务场景，适合使用 `varchar`，能够减少空间
varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。
根据业务区分使用 datetime/timestamp
说明：前者占用 5 个字节，后者占用 4 个字节，存储年使用 YEAR，存储日期使用 DATE，存储时间使用datetime
必须把字段定义为 NOT NULL 并设默认值

说明：
1）`NULL` 的列使用索引，索引统计，值都更加复杂，MySQL 更难优化
2）`NULL` 需要更多的存储空间
3）`NULL` 只能采用 `IS NULL` 或者 `IS NOT NULL`，而在 `=`/`!=`/`in`/`not in` 时有大坑
使用 INT UNSIGNED 存储 IPv4，不要用 char(15)
使用 varchar(20) 存储手机号，不要使用整数

说明：
1）牵扯到国家代号，可能出现 `+/-/()` 等字符，例如 `+86`
2）手机号不会用来做数学运算
3）`varchar` 可以模糊查询，例如 `like ‘138%’`
使用 TINYINT 来代替 ENUM
说明：ENUM 增加新值要进行 DDL 操作
表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint
（ 1 表示是，0 表示否）。

说明：任何字段如果为非负数，必须是 `unsigned`。
正例：表达逻辑删除的字段名 `is_deleted`，1 表示删除，0 表示未删除。
如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。
字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：

1）不是频繁修改的字段。
2）不是 `varchar` 超长字段，更不能是 `text` 字段。
正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。
合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。

正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。
对象	年龄区间	类型	字节	表示范围
人	150 岁之内	unsigned tinyint	1	0 到 255
龟	数百岁	unsigned smallint	2	无符号值：0 到 65535
恐龙化石	数千万年	unsigned int	4	无符号值：0 到约 42.9 亿
太阳	约 50 亿年	unsigned bigint	8	无符号值：0 到约 10 的 19 次方
​

索引规范
主键索引名为 pk_[字段名]；唯一索引名为 uk_[字段名]；普通索引名则为 idx_[字段名]；单张表索引数量建议控制在5个以内。
说明：

1）`pk_` 即 primary key；`uk_` 即 unique key；`idx_` 即 index 的简称。
2）互联网高并发业务，太多索引会影响写性能
3）生成执行计划时，如果索引太多，会降低性能，并可能导致MySQL选择不到最优索引
4）异常复杂的查询需求，可以选择ES等更为适合的方式存储
组合索引字段数不建议超过 5 个
说明：如果 5 个字段还不能极大缩小 row 范围，八成是设计有问题
超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。
说明：即使双表 join 也要注意表索引、SQL 性能。踩过因为 JOIN 字段类型不一致，而导致全表扫描的坑么？
理解组合索引最左前缀原则，避免重复建设索引，如果建立了 (a,b,c)，相当于建立了 (a), (a,b), (a,b,c)
在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。
说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上，可以使用 count(distinct left(列名, 索引长度))/count(*) 的区分度来确定。
页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。
如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。

正例：`where a=? and b=? order by c;` 索引：`a_b_c`
反例：索引中有范围查找，那么索引有序性无法利用，如：`WHERE a>10 ORDER BY b;` 索引 `a_b` 无法排序。
利用覆盖索引来进行查询操作，避免回表。

说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。
正例：能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种效果，用 `explain` 的结果，`extra` 列会出现：`using index`。
利用延迟关联或者子查询优化超多分页场景。

说明：MySQL 并不是跳过 `offset` 行，而是取 `offset+N` 行，然后返回放弃前 `offset` 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。
正例：先快速定位需要获取的 `id` 段，然后再关联：
SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id

SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。
说明：

1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。
2）ref 指的是使用普通的索引（normal index）。
3）range 对索引进行范围检索。
反例：explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。
建组合索引的时候，区分度最高的在最左边。

正例：如果 `where a=? and b=?` ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。
说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：`where a>? and b=?` 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。
防止因字段类型不同造成的隐式转换，导致索引失效。
创建索引时避免有如下极端误解：

1）宁滥勿缺。认为一个查询就需要建一个索引。
2）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。
3）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。
​

SQL 语句
禁止使用 select *，只获取必要字段
说明：

1）`select` 会增加 cpu/io/内存/带宽的消耗
2）指定字段能有效利用索引覆盖
3）指定字段查询，在表结构变更时，能保证对应用程序无影响
insert 必须指定字段，禁止使用 insert into T values()

说明：指定字段插入，在表结构变更时，能保证对应用程序无影响
不要使用 count(列名) 或 count(常量) 来替代 count(*)，count(*) 是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。

说明：`count(*)` 会统计值为 `NULL` 的行，而 `count(列名)` 不会统计此列为 `NULL` 值的行。
count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。
当某一列的值全是 NULL 时，count(col) 的返回结果为 0，但 sum(col) 的返回结果为 NULL，因此使用 sum() 时需注意 NPE 问题。

正例：可以使用如下方式来避免 `sum` 的 NPE 问题：`SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;`
注释：*NPE* 全称 NullPointerException 是指编程语言中的空指针异常。
使用 ISNULL() 来判断是否为 NULL 值。

说明：`NULL` 与任何值的直接比较都为 `NULL`。
1） `NULL<>NULL` 的返回结果是 `NULL`，而不是 `false`。
2） `NULL=NULL` 的返回结果是 `NULL`，而不是 `true`。
3） `NULL<>1` 的返回结果是 `NULL`，而不是 `true`。
在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。
不得使用外键与级联，一切外键概念必须在应用层解决。

说明：以学生和成绩的关系为例，学生表中的 `student_id` 是主键，那么成绩表中的 `student_id` 则为外键。如果更新学生表中的 `student_id`，同时触发成绩表中的 `student_id` 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。
禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。
数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。
in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控
制在 1000 个之内。
如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。

说明：
`SELECT LENGTH("轻松工作")；` 返回为 12；
`SELECT CHARACTER_LENGTH("轻松工作")；` 返回为 4；
如果需要存储表情，那么选择 `utfmb4` 来进行存储，注意它与 `utf-8` 编码的区别。
TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。

说明：`TRUNCATE TABLE` 在功能上与不带 `WHERE` 子句的 `DELETE` 语句相同。
​

以上内容，整理自阿里巴巴 Java开发手册和58到家MySQL军规升级版。
